{
  "version": 3,
  "sources": ["../../react-swipeable/src/types.ts", "../../react-swipeable/src/index.ts"],
  "sourcesContent": ["import * as React from \"react\";\r\n\r\nexport const LEFT = \"Left\";\r\nexport const RIGHT = \"Right\";\r\nexport const UP = \"Up\";\r\nexport const DOWN = \"Down\";\r\nexport type HandledEvents = React.MouseEvent | TouchEvent | MouseEvent;\r\nexport type Vector2 = [number, number];\r\nexport type SwipeDirections =\r\n  | typeof LEFT\r\n  | typeof RIGHT\r\n  | typeof UP\r\n  | typeof DOWN;\r\nexport interface SwipeEventData {\r\n  /**\r\n   * Absolute displacement of swipe in x. Math.abs(deltaX);\r\n   */\r\n  absX: number;\r\n  /**\r\n   * Absolute displacement of swipe in y. Math.abs(deltaY);\r\n   */\r\n  absY: number;\r\n  /**\r\n   * Displacement of swipe in x. (current.x - initial.x)\r\n   */\r\n  deltaX: number;\r\n  /**\r\n   * Displacement of swipe in y. (current.y - initial.y)\r\n   */\r\n  deltaY: number;\r\n  /**\r\n   * Direction of swipe - Left | Right | Up | Down\r\n   */\r\n  dir: SwipeDirections;\r\n  /**\r\n   * Source event.\r\n   */\r\n  event: HandledEvents;\r\n  /**\r\n   * True for the first event of a tracked swipe.\r\n   */\r\n  first: boolean;\r\n  /**\r\n   * Location where swipe started - [x, y].\r\n   */\r\n  initial: Vector2;\r\n  /**\r\n   * \"Absolute velocity\" (speed) - âˆš(absX^2 + absY^2) / time\r\n   */\r\n  velocity: number;\r\n  /**\r\n   * Velocity per axis - [ deltaX/time, deltaY/time ]\r\n   */\r\n  vxvy: Vector2;\r\n}\r\n\r\nexport type SwipeCallback = (eventData: SwipeEventData) => void;\r\nexport type TapCallback = ({ event }: { event: HandledEvents }) => void;\r\n\r\nexport type SwipeableDirectionCallbacks = {\r\n  /**\r\n   * Called after a DOWN swipe\r\n   */\r\n  onSwipedDown: SwipeCallback;\r\n  /**\r\n   * Called after a LEFT swipe\r\n   */\r\n  onSwipedLeft: SwipeCallback;\r\n  /**\r\n   * Called after a RIGHT swipe\r\n   */\r\n  onSwipedRight: SwipeCallback;\r\n  /**\r\n   * Called after a UP swipe\r\n   */\r\n  onSwipedUp: SwipeCallback;\r\n};\r\n\r\nexport type SwipeableCallbacks = SwipeableDirectionCallbacks & {\r\n  /**\r\n   * Called at start of a tracked swipe.\r\n   */\r\n  onSwipeStart: SwipeCallback;\r\n  /**\r\n   * Called after any swipe.\r\n   */\r\n  onSwiped: SwipeCallback;\r\n  /**\r\n   * Called for each move event during a tracked swipe.\r\n   */\r\n  onSwiping: SwipeCallback;\r\n  /**\r\n   * Called after a tap. A touch under the min distance, `delta`.\r\n   */\r\n  onTap: TapCallback;\r\n  /**\r\n   * Called for `touchstart` and `mousedown`.\r\n   */\r\n  onTouchStartOrOnMouseDown: TapCallback;\r\n  /**\r\n   * Called for `touchend` and `mouseup`.\r\n   */\r\n  onTouchEndOrOnMouseUp: TapCallback;\r\n};\r\n\r\n// Configuration Options\r\nexport type ConfigurationOptionDelta =\r\n  | number\r\n  | { [key in Lowercase<SwipeDirections>]?: number };\r\n\r\nexport interface ConfigurationOptions {\r\n  /**\r\n   * Min distance(px) before a swipe starts. **Default**: `10`\r\n   */\r\n  delta: ConfigurationOptionDelta;\r\n  /**\r\n   * Prevents scroll during swipe in most cases. **Default**: `false`\r\n   */\r\n  preventScrollOnSwipe: boolean;\r\n  /**\r\n   * Set a rotation angle. **Default**: `0`\r\n   */\r\n  rotationAngle: number;\r\n  /**\r\n   * Track mouse input. **Default**: `false`\r\n   */\r\n  trackMouse: boolean;\r\n  /**\r\n   * Track touch input. **Default**: `true`\r\n   */\r\n  trackTouch: boolean;\r\n  /**\r\n   * Allowable duration of a swipe (ms). **Default**: `Infinity`\r\n   */\r\n  swipeDuration: number;\r\n  /**\r\n   * Options for touch event listeners\r\n   */\r\n  touchEventOptions: { passive: boolean };\r\n}\r\n\r\nexport type SwipeableProps = Partial<SwipeableCallbacks & ConfigurationOptions>;\r\n\r\nexport type SwipeablePropsWithDefaultOptions = Partial<SwipeableCallbacks> &\r\n  ConfigurationOptions;\r\n\r\nexport interface SwipeableHandlers {\r\n  ref(element: HTMLElement | null): void;\r\n  onMouseDown?(event: React.MouseEvent): void;\r\n}\r\n\r\nexport type SwipeableState = {\r\n  cleanUpTouch?: () => void;\r\n  el?: HTMLElement;\r\n  eventData?: SwipeEventData;\r\n  first: boolean;\r\n  initial: Vector2;\r\n  start: number;\r\n  swiping: boolean;\r\n  xy: Vector2;\r\n};\r\n\r\nexport type StateSetter = (\r\n  state: SwipeableState,\r\n  props: SwipeablePropsWithDefaultOptions\r\n) => SwipeableState;\r\nexport type Setter = (stateSetter: StateSetter) => void;\r\nexport type AttachTouch = (\r\n  el: HTMLElement,\r\n  props: SwipeablePropsWithDefaultOptions\r\n) => () => void;\r\n", "/* global document */\r\nimport * as React from \"react\";\r\nimport {\r\n  AttachTouch,\r\n  SwipeDirections,\r\n  DOWN,\r\n  SwipeEventData,\r\n  HandledEvents,\r\n  LEFT,\r\n  RIGHT,\r\n  Setter,\r\n  ConfigurationOptions,\r\n  SwipeableDirectionCallbacks,\r\n  SwipeableHandlers,\r\n  SwipeableProps,\r\n  SwipeablePropsWithDefaultOptions,\r\n  SwipeableState,\r\n  SwipeCallback,\r\n  TapCallback,\r\n  UP,\r\n  Vector2,\r\n} from \"./types\";\r\n\r\nexport {\r\n  LEFT,\r\n  RIGHT,\r\n  UP,\r\n  DOWN,\r\n  SwipeDirections,\r\n  SwipeEventData,\r\n  SwipeableDirectionCallbacks,\r\n  SwipeCallback,\r\n  TapCallback,\r\n  SwipeableHandlers,\r\n  SwipeableProps,\r\n  Vector2,\r\n};\r\n\r\nconst defaultProps: ConfigurationOptions = {\r\n  delta: 10,\r\n  preventScrollOnSwipe: false,\r\n  rotationAngle: 0,\r\n  trackMouse: false,\r\n  trackTouch: true,\r\n  swipeDuration: Infinity,\r\n  touchEventOptions: { passive: true },\r\n};\r\nconst initialState: SwipeableState = {\r\n  first: true,\r\n  initial: [0, 0],\r\n  start: 0,\r\n  swiping: false,\r\n  xy: [0, 0],\r\n};\r\nconst mouseMove = \"mousemove\";\r\nconst mouseUp = \"mouseup\";\r\nconst touchEnd = \"touchend\";\r\nconst touchMove = \"touchmove\";\r\nconst touchStart = \"touchstart\";\r\n\r\nfunction getDirection(\r\n  absX: number,\r\n  absY: number,\r\n  deltaX: number,\r\n  deltaY: number\r\n): SwipeDirections {\r\n  if (absX > absY) {\r\n    if (deltaX > 0) {\r\n      return RIGHT;\r\n    }\r\n    return LEFT;\r\n  } else if (deltaY > 0) {\r\n    return DOWN;\r\n  }\r\n  return UP;\r\n}\r\n\r\nfunction rotateXYByAngle(pos: Vector2, angle: number): Vector2 {\r\n  if (angle === 0) return pos;\r\n  const angleInRadians = (Math.PI / 180) * angle;\r\n  const x =\r\n    pos[0] * Math.cos(angleInRadians) + pos[1] * Math.sin(angleInRadians);\r\n  const y =\r\n    pos[1] * Math.cos(angleInRadians) - pos[0] * Math.sin(angleInRadians);\r\n  return [x, y];\r\n}\r\n\r\nfunction getHandlers(\r\n  set: Setter,\r\n  handlerProps: { trackMouse: boolean | undefined }\r\n): [\r\n  {\r\n    ref: (element: HTMLElement | null) => void;\r\n    onMouseDown?: (event: React.MouseEvent) => void;\r\n  },\r\n  AttachTouch\r\n] {\r\n  const onStart = (event: HandledEvents) => {\r\n    const isTouch = \"touches\" in event;\r\n    // if more than a single touch don't track, for now...\r\n    if (isTouch && event.touches.length > 1) return;\r\n\r\n    set((state, props) => {\r\n      // setup mouse listeners on document to track swipe since swipe can leave container\r\n      if (props.trackMouse && !isTouch) {\r\n        document.addEventListener(mouseMove, onMove);\r\n        document.addEventListener(mouseUp, onUp);\r\n      }\r\n      const { clientX, clientY } = isTouch ? event.touches[0] : event;\r\n      const xy = rotateXYByAngle([clientX, clientY], props.rotationAngle);\r\n\r\n      props.onTouchStartOrOnMouseDown &&\r\n        props.onTouchStartOrOnMouseDown({ event });\r\n\r\n      return {\r\n        ...state,\r\n        ...initialState,\r\n        initial: xy.slice() as Vector2,\r\n        xy,\r\n        start: event.timeStamp || 0,\r\n      };\r\n    });\r\n  };\r\n\r\n  const onMove = (event: HandledEvents) => {\r\n    set((state, props) => {\r\n      const isTouch = \"touches\" in event;\r\n      // Discount a swipe if additional touches are present after\r\n      // a swipe has started.\r\n      if (isTouch && event.touches.length > 1) {\r\n        return state;\r\n      }\r\n\r\n      // if swipe has exceeded duration stop tracking\r\n      if (event.timeStamp - state.start > props.swipeDuration) {\r\n        return state.swiping ? { ...state, swiping: false } : state;\r\n      }\r\n\r\n      const { clientX, clientY } = isTouch ? event.touches[0] : event;\r\n      const [x, y] = rotateXYByAngle([clientX, clientY], props.rotationAngle);\r\n      const deltaX = x - state.xy[0];\r\n      const deltaY = y - state.xy[1];\r\n      const absX = Math.abs(deltaX);\r\n      const absY = Math.abs(deltaY);\r\n      const time = (event.timeStamp || 0) - state.start;\r\n      const velocity = Math.sqrt(absX * absX + absY * absY) / (time || 1);\r\n      const vxvy: Vector2 = [deltaX / (time || 1), deltaY / (time || 1)];\r\n\r\n      const dir = getDirection(absX, absY, deltaX, deltaY);\r\n\r\n      // if swipe is under delta and we have not started to track a swipe: skip update\r\n      const delta =\r\n        typeof props.delta === \"number\"\r\n          ? props.delta\r\n          : props.delta[dir.toLowerCase() as Lowercase<SwipeDirections>] ||\r\n            defaultProps.delta;\r\n      if (absX < delta && absY < delta && !state.swiping) return state;\r\n\r\n      const eventData = {\r\n        absX,\r\n        absY,\r\n        deltaX,\r\n        deltaY,\r\n        dir,\r\n        event,\r\n        first: state.first,\r\n        initial: state.initial,\r\n        velocity,\r\n        vxvy,\r\n      };\r\n\r\n      // call onSwipeStart if present and is first swipe event\r\n      eventData.first && props.onSwipeStart && props.onSwipeStart(eventData);\r\n\r\n      // call onSwiping if present\r\n      props.onSwiping && props.onSwiping(eventData);\r\n\r\n      // track if a swipe is cancelable (handler for swiping or swiped(dir) exists)\r\n      // so we can call preventDefault if needed\r\n      let cancelablePageSwipe = false;\r\n      if (\r\n        props.onSwiping ||\r\n        props.onSwiped ||\r\n        props[`onSwiped${dir}` as keyof SwipeableDirectionCallbacks]\r\n      ) {\r\n        cancelablePageSwipe = true;\r\n      }\r\n\r\n      if (\r\n        cancelablePageSwipe &&\r\n        props.preventScrollOnSwipe &&\r\n        props.trackTouch &&\r\n        event.cancelable\r\n      ) {\r\n        event.preventDefault();\r\n      }\r\n\r\n      return {\r\n        ...state,\r\n        // first is now always false\r\n        first: false,\r\n        eventData,\r\n        swiping: true,\r\n      };\r\n    });\r\n  };\r\n\r\n  const onEnd = (event: HandledEvents) => {\r\n    set((state, props) => {\r\n      let eventData: SwipeEventData | undefined;\r\n      if (state.swiping && state.eventData) {\r\n        // if swipe is less than duration fire swiped callbacks\r\n        if (event.timeStamp - state.start < props.swipeDuration) {\r\n          eventData = { ...state.eventData, event };\r\n          props.onSwiped && props.onSwiped(eventData);\r\n\r\n          const onSwipedDir =\r\n            props[\r\n              `onSwiped${eventData.dir}` as keyof SwipeableDirectionCallbacks\r\n            ];\r\n          onSwipedDir && onSwipedDir(eventData);\r\n        }\r\n      } else {\r\n        props.onTap && props.onTap({ event });\r\n      }\r\n\r\n      props.onTouchEndOrOnMouseUp && props.onTouchEndOrOnMouseUp({ event });\r\n\r\n      return { ...state, ...initialState, eventData };\r\n    });\r\n  };\r\n\r\n  const cleanUpMouse = () => {\r\n    // safe to just call removeEventListener\r\n    document.removeEventListener(mouseMove, onMove);\r\n    document.removeEventListener(mouseUp, onUp);\r\n  };\r\n\r\n  const onUp = (e: HandledEvents) => {\r\n    cleanUpMouse();\r\n    onEnd(e);\r\n  };\r\n\r\n  /**\r\n   * The value of passive on touchMove depends on `preventScrollOnSwipe`:\r\n   * - true => { passive: false }\r\n   * - false => { passive: true } // Default\r\n   *\r\n   * NOTE: When preventScrollOnSwipe is true, we attempt to call preventDefault to prevent scroll.\r\n   *\r\n   * props.touchEventOptions can also be set for all touch event listeners,\r\n   * but for `touchmove` specifically when `preventScrollOnSwipe` it will\r\n   * supersede and force passive to false.\r\n   *\r\n   */\r\n  const attachTouch: AttachTouch = (el, props) => {\r\n    let cleanup = () => {};\r\n    if (el && el.addEventListener) {\r\n      const baseOptions = {\r\n        ...defaultProps.touchEventOptions,\r\n        ...props.touchEventOptions,\r\n      };\r\n      // attach touch event listeners and handlers\r\n      const tls: [\r\n        typeof touchStart | typeof touchMove | typeof touchEnd,\r\n        (e: HandledEvents) => void,\r\n        { passive: boolean }\r\n      ][] = [\r\n        [touchStart, onStart, baseOptions],\r\n        // preventScrollOnSwipe option supersedes touchEventOptions.passive\r\n        [\r\n          touchMove,\r\n          onMove,\r\n          {\r\n            ...baseOptions,\r\n            ...(props.preventScrollOnSwipe ? { passive: false } : {}),\r\n          },\r\n        ],\r\n        [touchEnd, onEnd, baseOptions],\r\n      ];\r\n      tls.forEach(([e, h, o]) => el.addEventListener(e, h, o));\r\n      // return properly scoped cleanup method for removing listeners, options not required\r\n      cleanup = () => tls.forEach(([e, h]) => el.removeEventListener(e, h));\r\n    }\r\n    return cleanup;\r\n  };\r\n\r\n  const onRef = (el: HTMLElement | null) => {\r\n    // \"inline\" ref functions are called twice on render, once with null then again with DOM element\r\n    // ignore null here\r\n    if (el === null) return;\r\n    set((state, props) => {\r\n      // if the same DOM el as previous just return state\r\n      if (state.el === el) return state;\r\n\r\n      const addState: { cleanUpTouch?: () => void } = {};\r\n      // if new DOM el clean up old DOM and reset cleanUpTouch\r\n      if (state.el && state.el !== el && state.cleanUpTouch) {\r\n        state.cleanUpTouch();\r\n        addState.cleanUpTouch = void 0;\r\n      }\r\n      // only attach if we want to track touch\r\n      if (props.trackTouch && el) {\r\n        addState.cleanUpTouch = attachTouch(el, props);\r\n      }\r\n\r\n      // store event attached DOM el for comparison, clean up, and re-attachment\r\n      return { ...state, el, ...addState };\r\n    });\r\n  };\r\n\r\n  // set ref callback to attach touch event listeners\r\n  const output: { ref: typeof onRef; onMouseDown?: typeof onStart } = {\r\n    ref: onRef,\r\n  };\r\n\r\n  // if track mouse attach mouse down listener\r\n  if (handlerProps.trackMouse) {\r\n    output.onMouseDown = onStart;\r\n  }\r\n\r\n  return [output, attachTouch];\r\n}\r\n\r\nfunction updateTransientState(\r\n  state: SwipeableState,\r\n  props: SwipeablePropsWithDefaultOptions,\r\n  previousProps: SwipeablePropsWithDefaultOptions,\r\n  attachTouch: AttachTouch\r\n) {\r\n  // if trackTouch is off or there is no el, then remove handlers if necessary and exit\r\n  if (!props.trackTouch || !state.el) {\r\n    if (state.cleanUpTouch) {\r\n      state.cleanUpTouch();\r\n    }\r\n\r\n    return {\r\n      ...state,\r\n      cleanUpTouch: undefined,\r\n    };\r\n  }\r\n\r\n  // trackTouch is on, so if there are no handlers attached, attach them and exit\r\n  if (!state.cleanUpTouch) {\r\n    return {\r\n      ...state,\r\n      cleanUpTouch: attachTouch(state.el, props),\r\n    };\r\n  }\r\n\r\n  // trackTouch is on and handlers are already attached, so if preventScrollOnSwipe changes value,\r\n  // remove and reattach handlers (this is required to update the passive option when attaching\r\n  // the handlers)\r\n  if (\r\n    props.preventScrollOnSwipe !== previousProps.preventScrollOnSwipe ||\r\n    props.touchEventOptions.passive !== previousProps.touchEventOptions.passive\r\n  ) {\r\n    state.cleanUpTouch();\r\n\r\n    return {\r\n      ...state,\r\n      cleanUpTouch: attachTouch(state.el, props),\r\n    };\r\n  }\r\n\r\n  return state;\r\n}\r\n\r\nexport function useSwipeable(options: SwipeableProps): SwipeableHandlers {\r\n  const { trackMouse } = options;\r\n  const transientState = React.useRef({ ...initialState });\r\n  const transientProps = React.useRef<SwipeablePropsWithDefaultOptions>({\r\n    ...defaultProps,\r\n  });\r\n\r\n  // track previous rendered props\r\n  const previousProps = React.useRef<SwipeablePropsWithDefaultOptions>({\r\n    ...transientProps.current,\r\n  });\r\n  previousProps.current = { ...transientProps.current };\r\n\r\n  // update current render props & defaults\r\n  transientProps.current = {\r\n    ...defaultProps,\r\n    ...options,\r\n  };\r\n  // Force defaults for config properties\r\n  let defaultKey: keyof ConfigurationOptions;\r\n  for (defaultKey in defaultProps) {\r\n    if (transientProps.current[defaultKey] === void 0) {\r\n      (transientProps.current[defaultKey] as any) = defaultProps[defaultKey];\r\n    }\r\n  }\r\n\r\n  const [handlers, attachTouch] = React.useMemo(\r\n    () =>\r\n      getHandlers(\r\n        (stateSetter) =>\r\n          (transientState.current = stateSetter(\r\n            transientState.current,\r\n            transientProps.current\r\n          )),\r\n        { trackMouse }\r\n      ),\r\n    [trackMouse]\r\n  );\r\n\r\n  transientState.current = updateTransientState(\r\n    transientState.current,\r\n    transientProps.current,\r\n    previousProps.current,\r\n    attachTouch\r\n  );\r\n\r\n  return handlers;\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
